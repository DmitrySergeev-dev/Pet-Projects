"""
Сетевые подключения часто ненадежны, поэтому в коде приложения
могут возникать неожиданные исключения. Как должно вести себя
приложение в случае ошибки чтения или записи данных? Для тести-
рования изменим нашу реализацию echo – будем возбуждать исклю-
чение, если клиент передает особое слово: boom.

Если теперь клиент пришлет слово «boom», то мы возбудим ис-
ключение и задача завершится аварийно. И что произойдет в этом
случае? Мы увидим обратную трассу вызовов, содержащую преду-
преждение:
Task exception was never retrieved
future: <Task finished name='Task-2' coro=<echo() done, defined at
asyncio_echo.py:5> exception=Exception('Неожиданная ошибка сети')>
Traceback (most recent call last):
File "asyncio_echo.py", line 9, in echo
raise Exception("Неожиданная ошибка сети")
Exception: Unexpected network error

Важна здесь фраза «Task exception was never retrieved» (Исключение
задачи не извлекалось). Что она означает? Когда внутри задачи воз-
никает исключение, считается, что задача завершена, а ее результа-
том является исключение. Это значит, что в стек вызовов исключение
не попадает. И очистки здесь нет. Если это исключение возбуждается,
то мы не можем отреагировать на ошибку в задаче, потому что не
пытались его извлечь.

Чтобы исключение дошло до нас, задачу нужно вызывать в выражении await. В таком случае исключение будет возбуждено в точке await, и это отразится в трассе вызовов. Если не применить await к задаче в каком-то месте приложения, то мы рискуем никогда не увидеть возникшего исключения. Хотя в рассматриваемом примере мы видим сообщение, заданное в исключении, и можем подумать, что
проблемы нет, это приложение можно немного изменить, так что сообщение будет от нас скрыто.

Для демонстрации предположим, что вместо игнорирования задач
echo, созданных в listen_for_connections, мы сохраняем их в списке:
tasks = []
async def listen_for_connection(server_socket: socket,
loop: AbstractEventLoop):
while True:
connection, address = await loop.sock_accept(server_socket)
connection.setblocking(False)
print(f"Получено сообщение от {address}")
tasks.append(asyncio.create_task(echo(connection, loop)))

На первый взгляд, все должно работать как прежде. Отправив со-
общение «boom», мы должны увидеть исключение и предупреждение
о том, что исключение не извлекалось. Однако это не так – мы ничего
не увидим, пока не снимем приложение принудительно!

Все дело в том, что мы храним ссылку на задачу, а asyncio может на-
печатать сообщение и обратную трассу сбойной задачи, только когда
она убирается в мусор. Это и понятно – ведь нет никакого способа
узнать, не ожидают ли задачу в какой-то другой точке приложения,
где она возбудила бы исключение. Из-за этих осложнений мы либо
должны ждать задачи с помощью await, либо обрабатывать все исключения в самих задачах. Как поступить в нашем эхо-сервере?
Первое, что можно сделать, – обернуть код сопрограммы echo предложением try/catch, запротоколировать исключение и закрыть подключение.

Это решает неотложную проблему, из-за которой сервер ругается,
что исключение не извлекалось, – ведь мы обработали его в самой сопрограмме. Кроме того, сокет корректно закрывается в блоке finally,
так что в случае ошибки не остается висячего необработанного исключения.

Отметим, что в этой реализации все открытые подключения клиентов закрываются на этапе остановки приложения. Почему? В главе 2 мы говорили, что asyncio.run снимает все задачи, оставшиеся в момент остановки приложения. Мы также узнали, что, когда задача снимается, возбуждается исключение CancelledError в точке, где программа ждет ее с помощью await.

Здесь важно, где именно возбуждается исключение. Если наша задача ждет чего-то в предложении вида await loop.sock_recv, а мы эту задачу сняли, то CancelledError возбуждается в строке await loop.
sock_recv. Это значит, что в рассматриваемом случае будет выполнен блок finally, так как исключение было возбуждено в выражении await при снятии задачи. Если изменить блок except, так чтобы он перехватывал и протоколировал эти исключения, то мы увидим по одному исключению CancelledError на каждую задачу.

Итак, мы решили проблему обработки ошибок при отказе задач.
А что, если требуется произвести какую-то очистку после ошибок или
что-то сделать с задачами, оставшимися в момент остановки приложения? Для этой цели предназначены обработчики сигналов asyncio.
"""


import asyncio
import logging
from asyncio import AbstractEventLoop
import socket


async def listen_for_connections(
        server_socket: socket, loop: AbstractEventLoop
):
    while True:
        connection, address = await loop.sock_accept(server_socket)
        connection.setblocking(False)
        print(f'Получен запрос на подключение от "{address}"')
        asyncio.create_task(echo(connection, loop))


async def echo(
        connection: socket, loop: AbstractEventLoop
):
    try:
        while data := await loop.sock_recv(connection, 1024):
            if data == b'boom\r\n':
                raise Exception("Неожиданная ошибка сети")
            await loop.sock_sendall(connection, data)
    except Exception as ex:
        logging.exception(ex)
    finally:
        connection.close()


async def main():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_address = ('127.0.0.1', 8000)
    server_socket.setblocking(False)
    server_socket.bind(server_address)
    server_socket.listen()

    await listen_for_connections(server_socket, asyncio.get_event_loop())

asyncio.run(main())


