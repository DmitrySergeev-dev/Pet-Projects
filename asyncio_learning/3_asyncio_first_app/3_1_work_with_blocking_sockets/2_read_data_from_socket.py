"""
Теперь, когда сервер, способный принимать запросы на подключе-
ние, создан, посмотрим, как читать посылаемые ему данные. В классе
socket имеется метод recv, который позволяет получать данные из
сокета. Метод принимает целое число, показывающее, сколько бай-
тов мы хотим прочитать. Это важно, потому что мы не можем про-
читать из сокета сразу все данные, а должны сохранять их в буфере,
пока не дойдем до конца.
В данном случае концом считается пара символов: возврат карет-
ки, перевод строки, или '\r\n'. Именно эта пара добавляется в конец
строки, когда пользователь нажимает клавишу Enter в telnet. Чтобы
продемонстрировать, как работает буферизация небольших сообще-
ний, зададим размер буфера заведомо малым. В реальных приложе-
ниях нужен буфер побольше, например на 1024 байта. Большой буфер
позволит воспользоваться механизмом буферизации на уровне опера-
ционной системы, это эффективнее, чем буферизация в приложении
"""

import socket

"""
Здесь мы ждем запроса на подключение в функции server_socket.accept, как и раньше. Получив запрос, мы пытаемся принять два байта и сохранить их в буфере. Затем входим в цикл и на каждой итерации проверяем, заканчивается ли буфер символами возврата каретки
и перевода строки. Если нет, то получаем еще два байта, печатаем их и добавляем в буфер. После получения '\r\n' мы выходим из цикла и печатаем все сообщение, полученное от клиента, а затем закрываем серверный сокет в блоке finally. Таким образом, соединение будет гарантированно закрыто, даже если при чтении данных возникнет исключение.
"""
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server_address = ('127.0.0.1', 8000)
server_socket.bind(server_address)
server_socket.listen()
try:
    connection, client_address = server_socket.accept()
    print(f'Получен запрос на подключение от {client_address}!')
    buffer = b''
    while buffer[-2:] != b'\r\n':
        data = connection.recv(2)
        if not data:
            break
        else:
            print(f'Получены данные: {data}!')
            buffer = buffer + data
    print(f"Все данные: {buffer}")
    connection.sendall(buffer)
finally:
    server_socket.close()

"""
Теперь после подключения к серверу с помощью telnet и отправки
сообщения мы должны увидеть на терминале это же сообщение. Мы
написали очень простой эхо-сервер!
Сейчас это приложение в каждый момент времени обслуживает
только одного клиента, но подключиться к одному серверному сокету
может несколько клиентов. Изменим код, разрешив одновременное
подключение нескольких клиентов. Попутно продемонстрируем, что
нормально поддержать несколько клиентов с помощью блокирую-
щих сокетов не получается.
"""
