"""
Сокет, находящийся в режиме прослушивания, допускает одновременное подключение нескольких клиентов. Это значит, что при повторном вызове socket.accept мы каждый раз будем получать новый клиентский сокет для чтения и записи данных. Зная это, мы можем без труда изменить предыдущий пример, так чтобы сервер обслуживал несколько клиентов. Будем в бесконечном цикле вызывать socket.accept для прослушивания новых подключений. Приняв подключение, добавим его в конец списка имеющихся подключений. Затем в цикле обойдем все подключения, примем из каждого данные и запишем их обратно в сокет, чтобы передать клиенту.
"""

import socket

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server_address = ('127.0.0.1', 8000)
server_socket.bind(server_address)
server_socket.listen()
connections = []
try:
    while True:
        connection, client_address = server_socket.accept()
        print(f'Получен запрос на подключение от {client_address}!')
        connections.append(connection)
        for connection in connections:
            buffer = b''
            while buffer[-2:] != b'\r\n':
                data = connection.recv(2)
                if not data:
                    break
                else:
                    print(f'Получены данные: {data}!')
                    buffer = buffer + data
                print(f"Все данные: {buffer}")
            connection.send(buffer)
finally:
    server_socket.close()


# Можем проверить эту версию. Подключимся с помощью telnet
# и введем сообщение. Затем можно подключиться из второго telnet-
# клиента и отправить другое сообщение. И тут же наткнемся на про-
# блему. Первый клиент работает и получает копии своих сообщений,
# как и положено, а вот второй не получает ничего. Связано это с тем,
# что по умолчанию сокеты блокирующие. Методы accept и recv бло-
# кируют выполнение программы, пока не получат данные. А значит,
# после того как первый клиент подключился, мы будем ждать, когда
# он отправит свое первое сообщение. А остальные клиенты в это вре-
# мя зависнут в ожидании следующей итерации цикла, которая не про-
# изойдет, пока не придут данные от первого клиента.
# Очевидно, что пользователям это не понравится; мы написали
# программу, которая не масштабируется на случай, когда клиентов
# больше одного. Эту проблему можно решить, переведя сокеты в не-
# блокирующий режим. Если сокет помечен как неблокирующий, его
# методы не будут блокировать выполнение программы в ожидании
# поступления данных.

