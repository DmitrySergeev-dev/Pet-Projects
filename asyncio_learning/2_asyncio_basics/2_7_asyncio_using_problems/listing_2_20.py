import asyncio

import requests

from asyncio_learning.util import async_timed


@async_timed()
async def get_example_status() -> int:
    return requests.get('http://www.example.com').status_code


@async_timed()
async def main():
    task_1 = asyncio.create_task(get_example_status())
    task_2 = asyncio.create_task(get_example_status())
    task_3 = asyncio.create_task(get_example_status())
    await task_1
    await task_2
    await task_3


asyncio.run(main())

"""
Может возникнуть соблазн использовать существующие библиотеки
ввода-вывода, обернув их сопрограммами. Однако при этом возник-
нут те же проблемы, что для счетных операций. Эти API будут блокиро-
вать главный поток. Поэтому, попытавшись выполнить блокирующий
вызов API в сопрограмме, мы заблокируем сам поток цикла событий,
а значит, воспрепятствуем выполнению всех остальных сопрограмм
и задач. Примерами блокирующих API является библиотека requests
или функция time.sleep. Вообще, любая функция, которая выполняет
ввод-вывод, не являясь сопрограммой, или занимает процессор дли-
тельными операциями, может считаться блокирующей.
В качестве примера попробуем трижды конкурентно получить код
состояния страницы www.example.com с помощью библиотеки re-
quests. Поскольку задачи запускаются конкурентно, можно ожидать,
что на все про все уйдет столько же времени, сколько на однократное
получение кода состояния.

Обратите
внимание, что полное время работы сопрограммы main приблизи-
тельно равно сумме времен запущенных задач получения кода со-
стояния, т. е. мы не получили никакого выигрыша от конкурентности.

И снова причина в том, что библиотека requests блокирующая, т. е.
блокирует поток, в котором выполняется. Поскольку asyncio однопо-
точная, библиотека requests блокирует цикл событий и не дает ниче-
му выполняться конкурентно.
Большинство API, с которыми мы обычно работаем, в настоящее
время являются блокирующими и без доработок работать с asyncio не
будут. Нужно использовать библиотеку, которая поддерживает сопро-
граммы и неблокирующие сокеты. А это значит, что если используе-
мая вами библиотека не возвращает сопрограммы и вы не употре-
бляете await в собственных сопрограммах, то, вероятно, совершаете
блокирующий вызов.
В примере выше мы могли бы использовать библиотеку aiohttp,
в которой используются неблокирующие сокеты и которая возвраща-
ет сопрограммы, тогда с конкурентностью все было бы нормально.
Мы познакомимся с этой библиотекой в главе 4.
Если вы все-таки хотите использовать библиотеку requests, то син-
таксис async применить можно, но нужно явно попросить asyncio за-
действовать многопоточность с помощью исполнителя пула потоков.
Как это делается, узнаем в главе 7.
Мы рассказали, на что обращать внимание при работе с asyncio,
и написали несколько простых приложений. До сих пор мы не соз-
давали и не конфигурировали цикл событий самостоятельно, а по-
лагались на уже готовые методы. В следующем разделе научимся
создавать цикл событий, что позволит нам получить доступ к низ-
коуровневой функциональности asyncio и конфигурационным свой-
ствам цикла событий.
"""
