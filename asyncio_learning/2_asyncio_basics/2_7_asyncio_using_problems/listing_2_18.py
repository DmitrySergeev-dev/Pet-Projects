import asyncio

from asyncio_learning.util import async_timed


@async_timed()
async def cpu_bound_work() -> int:
    counter = 0
    for i in range(100000000):
        counter = counter + 1
    return counter


@async_timed()
async def main():
    task_one = asyncio.create_task(cpu_bound_work())
    task_two = asyncio.create_task(cpu_bound_work())
    await task_one
    await task_two


asyncio.run(main())

"""
В программе могут быть функции, выполняющие длительные вы-
числения, например обход большого словаря или математические
расчеты. Если есть возможность выполнять эти функции конку-
рентно, то может возникнуть идея поместить их в отдельные за-
дачи. В принципе, ничего плохого в этом нет, но нужно помнить,
что модель конкурентности в asyncio однопоточная. Это значит, что
действуют все ограничения одного потока и глобальной блокировки
интерпретатора.
Чтобы убедиться в этом, попробуем запустить счетные функции
конкурентно.
Выполнив этот код, мы увидим, что, несмотря на создание двух
задач, он по-прежнему работает последовательно: сначала задача 1,
потом – 2, и, значит, общее время работы складывается из двух об-
ращений к cpu_bound_work.
Глядя на этот результат, мы можем подумать, что нет ничего пло-
хого в том, чтобы повсюду расставить async и await. В конце концов,
времени-то уходит столько же, сколько при последовательном вы-
полнении. Однако при таком подходе мы можем оказаться в ситуа-
ции, когда производительность приложения падает. Особенно если
в программе есть другие сопрограммы или задачи, в которых встре-
чаются выражения await. Рассмотрим создание двух счетных задач
наряду с длительной задачей, например нашей сопрограммой delay.
См. listing_2_19.py
"""

