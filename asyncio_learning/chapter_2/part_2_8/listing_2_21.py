import asyncio


async def main():
    await asyncio.sleep(1)
    loop = asyncio.new_event_loop()
    try:
        loop.run_until_complete(main())
    finally:
        loop.close()


"""
До сих пор мы пользовались вспомогательной функцией asyncio.run,
которая за кулисами создавала цикл событий и запускала приложение.
В силу своей простоты это предпочтительный метод создания цикла
событий. Но бывает, что функциональность, предлагаемая asyncio.
run, нас не устраивает. Например, что, если мы хотим реализовать
специальную логику остановки задач, например дать оставшимся задачам завершиться, а не останавливать их, как делает asyncio.run?
Кроме того, могут понадобиться методы самого цикла событий. Как
правило, они низкоуровневые, так что злоупотреблять ими не стоит.
Однако если нужно сделать что-то нестандартное, например работать
с сокетами напрямую или запланировать задачу на конкретный момент в будущем, то доступ к циклу событий необходим. Мы, конечно,
не хотим и не должны увлекаться ручным управлением циклом событий, но временами от этого никуда не деться.

Мы можем создать цикл событий, воспользовавшись методом asyn-
cio.new_event_loop. Он возвращает экземпляр цикла событий, кото-
рый дает доступ ко всем низкоуровневым методам, в частности мето-
ду run_until_complete, который принимает сопрограмму и исполняет
ее до завершения. Закончив работу с циклом событий, мы должны за-
крыть его, чтобы освободить занятые ресурсы. Обычно это делается
в блоке finally, чтобы цикл был закрыт даже в случае исключения.
Ниже показано, как создать цикл событий и запустить в нем прило-
жение asyncio.
Это похоже на то, что происходит при вызове asyncio.run, с той
разницей, что оставшиеся задачи не отменяются. Если нам нужна
специальная логика очистки, то ее следует реализовать в предложе-
нии finally.
"""
